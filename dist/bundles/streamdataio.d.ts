// Generated by dts-bundle v0.7.3

export interface StreamdataAuthStrategy {
    signUrl(url: string): string;
}

export const DefaultStreamDataProxyURL: any;
export const DefaultStreamDataProxyVervion = "v1";
export const LegacyStreamDataProxy: any;

export let URL: any;
export let EventSource: any;

export { StreamDataIo, StreamdataProxySubscriber, StreamdataLegacySubscriber, StreamdataTopicSubscriber, StreamdataUrlSubscriber, EventType, StreamdataLegacyError, StreamdataProxyError, StreamdataAuthStrategy, DefaultStreamDataProxyURL, DefaultStreamDataProxyVervion, LegacyStreamDataProxy, JsonHelper, Listeners, Logger, LogLevel };
export const createEventSource: typeof StreamDataIo.createEventSource;
export const subscribeToUrl: typeof StreamDataIo.subscribeToUrl;
export const subscribeToTopic: typeof StreamDataIo.subscribeToTopic;

export type StreamDataSource = 'server' | 'client';
export class StreamdataLegacyError {
        static readonly DEFAULT_CAUSE: string;
        static readonly DEFAULT_MESSAGE: string;
        static readonly DEFAULT_STATUS: number;
        static readonly DEFAULT_SOURCE: StreamDataSource;
        status: number | string;
        cause: string;
        message: string;
        timestamp: string;
        source: string;
        original: any;
        constructor(status: number | string, cause: string, message: string, timestamp?: string, source?: StreamDataSource, original?: any);
        /**
            * @memberOf StreamdataLegacyError#
            * @return {boolean} true if error is from server side.
            */
        readonly isServer: boolean;
        /**
            * @memberOf StreamdataLegacyError#
            * @return {boolean} true if error is from client side.
            */
        readonly isClient: boolean;
        static createDefault(original?: any): StreamdataLegacyError;
}

export type ErrorCategory = 'ClientException' | 'ServerException' | 'TopicException';
export class StreamdataProxyError {
        datetime: string;
        code: number | string;
        message: string;
        category: ErrorCategory;
        status?: number | string;
        original?: any;
        constructor(error?: any);
        /**
            * @memberOf StreamdataProxyError#
            * @return {boolean} true if error is from server side.
            */
        readonly isServer: boolean;
        /**
            * @memberOf StreamdataProxyError#
            * @return {boolean} true if error is from client side.
            */
        readonly isClient: boolean;
        /**
            * @memberOf StreamdataProxyError#
            * @return {boolean} true if error is from topic side.
            */
        readonly isTopic: boolean;
}

export class StreamdataLegacySubscriber extends StreamdataProxySubscriber<StreamdataLegacyError> {
    constructor(_url: string, appToken: string, _headers?: string[], _authStrategy?: StreamdataAuthStrategy);
    protected getStreamingUrl(): URL;
    protected buildError(error: any): StreamdataLegacyError;
}

export abstract class StreamdataProxySubscriber<E> {
    protected _subscriberKey: string;
    protected static readonly X_SD_SUBSCRIBER_KEY: string;
    protected constructor(_subscriberKey: string);
    protected _proxy: URL;
    proxy: string | URL;
    open(): StreamdataProxySubscriber<E>;
    close(): StreamdataProxySubscriber<E>;
    onOpen(callback: (data: any) => void, thisArg?: any): StreamdataProxySubscriber<E>;
    onError(callback: (data: E) => void, thisArg?: any): StreamdataProxySubscriber<E>;
    onData(callback: (data: any) => void, thisArg?: any): StreamdataProxySubscriber<E>;
    onPatch(callback: (data: any) => void, thisArg?: any): StreamdataProxySubscriber<E>;
    onMonitor(callback: (data: any) => void, thisArg?: any): StreamdataProxySubscriber<E>;
    isConnected(): boolean;
    protected abstract getStreamingUrl(): URL;
    protected abstract buildError(error: any): E;
}

export class StreamdataTopicSubscriber extends StreamdataProxySubscriber<StreamdataProxyError> {
    constructor(_topicId: string, subscriberKey: string);
    version: string;
    protected getStreamingUrl(): URL;
    protected buildError(error: any): StreamdataProxyError;
}

export class StreamdataUrlSubscriber extends StreamdataProxySubscriber<StreamdataProxyError> {
    constructor(_url: string, subscriberKey: string);
    protected getStreamingUrl(): URL;
    protected buildError(error: any): StreamdataProxyError;
}

export enum EventType {
    OPEN = "open",
    ERROR = "error",
    DATA = "data",
    PATCH = "patch",
    MONITOR = "monitor"
}

/**
    * Streamdata.io JavaScript SDK
    */
export class StreamDataIo {
        /**
            * @deprecated Since version 2.1.0. Use subscribeToUrl instead.
            *
            * <p>Create a new instance of the <code>StreamdataEventSource</code> prototype.</p>
            *
            * <p>The <code>StreamdataEventSource</code> is the main entry point for establishing Server Sent Event connection to a targeted JSON REST service URL.</p>
            *
            * @param {String} url Mandatory. The targeted REST URL is formatted as follow:
            * <pre><code>protocol://url(:port)(/localpath(?queryparameters))</code></pre>
            *
            * @param {String} appToken Mandatory. The application token to authentify the request
            *
            * @param {Array} headers Optional. Any specific headers that have to be added to the request. It must be an array with the following structure:<code>['Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==']</code>
            *
            * @param {Object} authStrategy Optional. An object which will enable HMAC signature of the request. You can create this object as follow:
            * <pre><code>
            * // setup headers
            * var headers = [];
            * // setup signatureStrategy
            * var signatureStrategy = AuthStrategy.newSignatureStrategy('NmEtYTljN2UtYmM1MGZlMGRiNGFQzYS00MGRkLTkNTZlMDY1','NTEtMTQxNiWIzMDEC00OWNlLThmNGYtY2ExMDJxO00NzNhLTgtZWY0MjOTc2YmUxODFiZDU1NmU0ZDAtYWU5NjYxMGYzNDdi');
            * // instantiate an eventSource
            * var eventSource = streamdataio.createEventSource('http://myRestservice.com/stocks','NmEtYTljN2UtYmM1MGZlMGRiNGFQzYS00MGRkLTkNTZlMDY1',headers,signatureStrategy);
            *
            * </code></pre>
            * @returns {StreamdataEventSource}
            */
        static createEventSource(url: string, appToken: string, headers?: string[], authStrategy?: StreamdataAuthStrategy): StreamdataLegacySubscriber;
        static subscribeToUrl(url: string, subscriberKey: string): StreamdataUrlSubscriber;
        static subscribeToTopic(topicId: string, subscriberKey: string): StreamdataTopicSubscriber;
}

export class JsonHelper {
    static validate(stringObj: string): boolean;
    static parse(stringObj: string): any;
    static stringify(obj: any): string;
}

export class Listeners<T> {
        /**
            * Return the registered listeners
            *
            * @memberOf Listeners#
            */
        readonly listeners: Listener<T>[];
        /**
            * @param data
            * @memberOf Listeners#
            */
        fire(data?: T): void;
        /**
            * @memberOf Listeners#
            * @param callback
            * @param thisArg
            */
        addCallback(callback: (data: T) => void, thisArg?: any): Listener<T>;
        /**
            * @memberOf Listeners#
            * @param listener
            */
        add(listener: Listener<T>): Listener<T>;
        /**
            * @memberOf Listeners#
            * @param listener
            */
        remove(listener: Listener<T>): void;
}
export interface Listener<T> {
        callback: (data: T) => void;
        thisArg?: any;
}

export enum LogLevel {
        ERROR = 0,
        WARN = 1,
        INFO = 2,
        DEBUG = 3
}
export class Logger {
        /**
            * @private
            * @memberOf Logger#
            */
        static console: Console;
        /**
            * @private
            * @memberOf Logger#
            */
        static level: LogLevel;
        static debug(msg: string, ...args: any[]): void;
        static info(msg: string, ...args: any[]): void;
        static warn(msg: string, ...args: any[]): void;
        static error(msg: string, ...args: any[]): void;
}

export class Preconditions {
        /**
            * @memberOf Preconditions#
            * check if the value is not null
            * @param {*} value
            * @param {string} message
            */
        static checkNotNull(value: any, message: string): any;
        /**
            * @memberOf Preconditions#
            * log deprecated warning
            * @param {string} functionName
            * @param {string} message
            */
        static deprecated(functionName: string, message: string): void;
        /**
            * @memberOf Preconditions#
            * check is the provided expression is true
            * @param {*} expression
            * @param {string} message
            */
        static checkExpression(expression: boolean, message: string): void;
}

